/**
 * This file is part of the simple-css-tokenizer package.
 *
 * (c) Vjacheslav Trushkin <cyberalien@gmail.com>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

"use strict";

(function () {

    var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
    
    function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
    
    (function (_global) {
        var modules = {};
    
        /**
         * Parse error class
         */
        var ParseError = function () {
            /**
             * Constructor
             *
             * @param {string} message Error message
             * @param {string} css CSS
             * @param {number} index Index where error occurred, -1 if n/a
             */
            function ParseError(message, css, index) {
                _classCallCheck(this, ParseError);

                this.message = message;

                if (typeof index === 'number' && index !== -1) {
                    var start = index;

                    // Check for space on left side of remaining code to calculate line start correctly
                    var remaining = css.slice(index) + '!';
                    var trimmed = remaining.trim();
                    var end = start + remaining.length - trimmed.length;

                    var code = css.slice(0, end);
                    var line = code.length - code.replace(/\n/g, '').length + 1;
                    this.message += ' on line ' + line;
                }
            }

            /**
             * Get message
             *
             * @returns {string}
             */


            _createClass(ParseError, [{
                key: 'getMessage',
                value: function getMessage() {
                    return this.message;
                }
            }]);

            return ParseError;
        }();

        modules['Error'] = ParseError;
    })();
    (function () {
        /**
         * Class that converts tokens list or tree back to css
         */
        var Builder = function () {
            /**
             * Constructor
             *
             * @param {object} [options]
             */
            function Builder(options) {
                _classCallCheck(this, Builder);

                options = options === void 0 ? {} : options;

                this.minify = options.minify === void 0 ? false : options.minify;
                this.tab = this.minify ? '' : options.tab === void 0 ? '\t' : options.tab;
                this.newline = this.minify ? '' : options.newline === void 0 ? '\n' : options.newline;
                this.newLineAfterSelector = options.newLineAfterSelector === void 0 ? true : options.newLineAfterSelector;
                this.ruleSeparator = this.minify ? ':' : ': ';
                this.selectorsSeparator = this.minify ? ',' : ', ';
                this.ruleModifiers = options.ruleModifiers !== void 0 ? options.ruleModifiers : ['default', 'important'];
            }

            /**
             * Convert list of tokens to string
             *
             * @param {Array} tokens
             * @returns {string}
             */


            _createClass(Builder, [{
                key: 'build',
                value: function build(tokens) {
                    return this._build(tokens, '').trim();
                }

                /**
                 * Convert list of tokens to string
                 *
                 * @param {Array} tokens
                 * @param {string} space
                 * @returns {string}
                 * @private
                 */

            }, {
                key: '_build',
                value: function _build(tokens, space) {
                    var _this = this;

                    var output = '',
                        lastToken = false,
                        level = 0;

                    tokens.forEach(function (token) {
                        switch (token.token) {
                            case 'code':
                                output += space + token.code + _this.newline;
                                break;

                            case '}':
                                level--;
                                space = space.slice(_this.tab.length);
                                output += space + '}' + _this.newline;
                                break;

                            case '{':
                                if (lastToken === '}') {
                                    // Double new line between 2 items in same scope
                                    output += _this.newline;
                                }
                                if (token.selectors !== void 0) {
                                    output += space + token.selectors.join(_this.selectorsSeparator);
                                } else if (token.atRule !== void 0) {
                                    output += space + '@' + token.atRule;
                                    if (token.atValues && token.atValues.length) {
                                        var values = token.atValues.join(_this.selectorsSeparator);
                                        output += values.length ? ' ' + values : '';
                                    }
                                } else {
                                    // Error - use code as backup
                                    output += space + token.code;
                                }
                                output += (_this.newLineAfterSelector ? _this.newline + space : _this.minify ? '' : ' ') + '{' + _this.newline;
                                if (token.children) {
                                    output += _this._build(token.children, space + _this.tab);
                                    output += space + '}' + _this.newline;
                                } else {
                                    level++;
                                    space += _this.tab;
                                }
                                break;

                            case 'rule':
                                output += space + token.key + _this.ruleSeparator + token.value;
                                _this.ruleModifiers.forEach(function (mod) {
                                    if (token[mod]) {
                                        output += ' !' + mod;
                                    }
                                });
                                output += ';' + _this.newline;
                                break;
                        }
                        lastToken = token.token;
                    });

                    return output;
                }
            }]);

            return Builder;
        }();

        modules['Builder'] = Builder;
    })();
    (function () {
        var ParseError = modules['Error'];
        var Builder = modules['Builder'];

        /**
         * Class that converts css code into list or tree of tokens
         */

        var Tokenizer = function () {
            _createClass(Tokenizer, null, [{
                key: 'build',

                /**
                 * Convert list or tree of tokens to string
                 *
                 * @param {Array} tokens
                 * @param {object} [options]
                 * @returns {string}
                 */
                value: function build(tokens, options) {
                    return new Builder(options).build(tokens);
                }

                /**
                 * Constructor
                 *
                 * @param {object} [options]
                 */

            }]);

            function Tokenizer(options) {
                _classCallCheck(this, Tokenizer);

                options = options === void 0 ? {} : options;

                this.splitRules = options.splitRules !== false;
                this.ignoreErrors = options.ignoreErrors !== false;
                this.lessSyntax = options.lessSyntax === true;
                this.ruleModifiers = options.ruleModifiers !== void 0 ? options.ruleModifiers : ['default', 'important'];
            }

            /**
             * Get tokens as tree
             *
             * @param {string} css
             * @returns {Array}
             */


            _createClass(Tokenizer, [{
                key: 'tree',
                value: function tree(css) {
                    // Do stuff
                    this._tokens = this.tokenize(css);
                    var results = this._parseTokens(this._tokens.shift());

                    // Add remaining items to root element
                    while (this._tokens.length) {
                        if (!this.ignoreErrors) {
                            this.errors.push(new ParseError('Unmatched }', this._css, this._tokens[0].index));
                        }
                        results = results.concat(this._parseTokens(this._tokens.shift()));
                    }

                    return results;
                }

                /**
                 * Convert css into list of tokens
                 *
                 * @param {string} css
                 * @returns {Array}
                 */

            }, {
                key: 'tokenize',
                value: function tokenize(css) {
                    var _this2 = this;

                    this._css = css;
                    this._cssLC = css.toLowerCase();
                    this.errors = [];

                    var start = 0,
                        words = [],
                        items = [],
                        depth = 0,
                        functionDepth = 0,
                        expressionDepth = 0,
                        blockStart = 0,
                        selectorStart = 0,
                        error = false,
                        // used to track invalid items
                    cssLength = this._css.length;

                    var validTokens = ['"', "'", '/*', '{', '}', ';', 'url(', '\\'];
                    if (this.lessSyntax) {
                        validTokens = validTokens.concat(['(', ')', '//', '@{', '#{']);
                    }

                    this._findTokens(validTokens).forEach(function (token) {
                        if (token.index < start) {
                            return;
                        }

                        var end = void 0;

                        switch (token.token) {
                            case '//':
                                // Skip to end of line
                                words.push({
                                    type: 'text',
                                    text: _this2._css.slice(start, token.index),
                                    index: start
                                });
                                start = token.index;

                                var end1 = _this2._css.indexOf('\n', start + 2);
                                var end2 = _this2._css.indexOf('\r', start + 2);
                                end = end1 === -1 ? end2 : end2 === -1 ? end1 : Math.min(end1, end2);
                                if (end === -1) {
                                    // Last string
                                    start = cssLength;
                                    break;
                                }

                                start = end + 1;
                                break;

                            case '/*':
                                // Skip to end of comment
                                words.push({
                                    type: 'text',
                                    text: _this2._css.slice(start, token.index),
                                    index: start
                                });
                                start = token.index;

                                end = _this2._css.indexOf('*/', start + 2);
                                if (end === -1) {
                                    // Skip to end of file
                                    if (!_this2.ignoreErrors) {
                                        _this2.errors.push(new ParseError('Missing comment closing statement', _this2._css, start));
                                        error = true;
                                    }
                                    start = cssLength;
                                    break;
                                }

                                start = end + 2;
                                break;

                            case '\\':
                                // Escaped character, skip next character
                                words.push({
                                    type: 'text',
                                    text: _this2._css.slice(start, token.index + 2),
                                    index: start
                                });
                                start = token.index + 2;
                                break;

                            case 'url(':
                                words.push({
                                    type: 'text',
                                    text: _this2._css.slice(start, token.index),
                                    index: start
                                });
                                start = token.index;

                                // Skip to end of URL
                                end = _this2._findEndOfURL(start);
                                if (typeof end !== 'number') {
                                    // Invalid URL - skip "url"
                                    words.push({
                                        type: 'text',
                                        text: _this2._css.slice(start, start + 3),
                                        index: start
                                    });
                                    if (!_this2.ignoreErrors) {
                                        _this2.errors.push(new ParseError('Incomplete URL', _this2._css, start));
                                        error = true;
                                    }
                                    start += 3;
                                    break;
                                }
                                words.push({
                                    type: 'url',
                                    text: _this2._css.slice(start, end),
                                    index: start
                                });
                                start = end;
                                break;

                            case '"':
                            case "'":
                                words.push({
                                    type: 'text',
                                    text: _this2._css.slice(start, token.index),
                                    index: start
                                });
                                start = token.index;

                                // Skip to end of quoted string
                                end = _this2._findEndOfQuotedString(token.token, start);
                                if (end === false) {
                                    // Missing closing quote
                                    if (_this2.ignoreErrors) {
                                        words.push({
                                            type: 'text',
                                            text: _this2._css.slice(start, start + 1),
                                            index: start
                                        });
                                        start++;
                                    } else {
                                        _this2.errors.push(new ParseError('Missing closing ' + token.token, _this2._css, start));
                                        error = true;
                                        words.push({
                                            type: 'code',
                                            text: _this2._css.slice(start),
                                            index: start
                                        });
                                        start = cssLength;
                                    }
                                    break;
                                }
                                words.push({
                                    type: 'string',
                                    text: _this2._css.slice(start, end),
                                    index: start
                                });
                                start = end;
                                break;

                            case ';':
                                if (functionDepth > 0) {
                                    break;
                                }
                                if (_this2.splitRules) {
                                    words.push({
                                        type: 'text',
                                        text: _this2._css.slice(start, token.index),
                                        index: start
                                    });
                                    items.push(_this2._checkRule(words, token.token, error));
                                    if (error) {
                                        items[items.length - 1].error = true;
                                        error = false;
                                    }
                                }
                                selectorStart = start = token.index + 1;
                                words = [];
                                break;

                            case '{':
                                // Get selector
                                if (!_this2.splitRules) {
                                    if (selectorStart > blockStart) {
                                        var code = _this2._css.slice(blockStart, selectorStart).trim();
                                        if (code.length) {
                                            items.push({
                                                token: 'code',
                                                code: code,
                                                index: blockStart
                                            });
                                            if (error) {
                                                items[items.length - 1].error = true;
                                                error = false;
                                            }
                                        }
                                    }
                                }
                                words.push({
                                    type: 'text',
                                    text: _this2._css.slice(start, token.index),
                                    index: start
                                });
                                items.push(_this2._checkSelectors(words));
                                if (error) {
                                    items[items.length - 1].error = true;
                                    error = false;
                                }

                                blockStart = selectorStart = start = token.index + 1;
                                words = [];
                                depth++;
                                break;

                            case '}':
                                if (expressionDepth > 0) {
                                    // LESS/SASS expression
                                    if (expressionDepth === 1 && _this2.splitRules) {
                                        // Find start of expression
                                        var found = false,
                                            text = _this2._css.slice(start, token.index + 1);

                                        for (var i = words.length - 1; i >= 0; i--) {
                                            if (words[i].beforeExpression) {
                                                found = true;
                                                delete words[i].beforeExpression;
                                                if (i === words.length - 1) {
                                                    // Previous token starts expression - do not change word tokens
                                                    words.push({
                                                        type: 'expression',
                                                        text: text,
                                                        index: start
                                                    });
                                                } else {
                                                    // Merge with previous tokens
                                                    start = words[i + 1].index;
                                                    words = words.slice(0, i + 1);
                                                    words.push({
                                                        type: 'expression',
                                                        text: text,
                                                        index: start
                                                    });
                                                }
                                                break;
                                            }
                                            text = words[i].text + text;
                                        }
                                        if (!found) {
                                            words.push({
                                                type: 'expression',
                                                text: text,
                                                index: start,
                                                error: true
                                            });
                                        }
                                        start = token.index + 1;
                                    }
                                    expressionDepth--;
                                    break;
                                }
                                // End of block
                                if (_this2.splitRules) {
                                    words.push({
                                        type: 'text',
                                        text: _this2._css.slice(start, token.index),
                                        index: start
                                    });
                                    items.push(_this2._checkRule(words, '', error));
                                    if (error) {
                                        items[items.length - 1].error = true;
                                    }
                                } else {
                                    var _code = _this2._css.slice(blockStart, token.index).trim();
                                    if (_code.length) {
                                        items.push({
                                            token: 'code',
                                            code: _code,
                                            index: blockStart
                                        });
                                        if (error) {
                                            items[items.length - 1].error = true;
                                        }
                                    }
                                }
                                error = false;
                                items.push({
                                    token: '}',
                                    index: token.index
                                });
                                error = false;

                                if (!depth && !_this2.ignoreErrors) {
                                    _this2.errors.push(new ParseError('Unexpected }', _this2._css, token.index));
                                }
                                depth--;

                                blockStart = selectorStart = start = token.index + 1;
                                words = [];
                                functionDepth = 0;
                                break;

                            case '(':
                                // Function with LESS syntax enabled
                                if (_this2.splitRules) {
                                    var row = {
                                        type: 'text',
                                        text: _this2._css.slice(start, token.index),
                                        index: start
                                    };
                                    if (!functionDepth) {
                                        row.beforeFunction = true;
                                    }
                                    words.push(row);
                                    start = token.index;
                                }
                                functionDepth++;
                                break;

                            case ')':
                                // End of function with LESS syntax enabled
                                if (functionDepth === 1 && _this2.splitRules) {
                                    // Find start of function
                                    var _found = false,
                                        _text = _this2._css.slice(start, token.index + 1);

                                    for (var _i = words.length - 1; _i >= 0; _i--) {
                                        if (words[_i].beforeFunction) {
                                            _found = true;
                                            delete words[_i].beforeFunction;
                                            if (_i === words.length - 1) {
                                                // Previous token starts function - do not change word tokens
                                                words.push({
                                                    type: 'function',
                                                    text: _text,
                                                    index: start
                                                });
                                            } else {
                                                // Merge with previous tokens
                                                start = words[_i + 1].index;
                                                words = words.slice(0, _i + 1);
                                                words.push({
                                                    type: 'function',
                                                    text: _text,
                                                    index: start
                                                });
                                            }
                                            break;
                                        }
                                        _text = words[_i].text + _text;
                                    }
                                    if (!_found) {
                                        words.push({
                                            type: 'function',
                                            text: _text,
                                            index: start,
                                            error: true
                                        });
                                    }
                                    start = token.index + 1;
                                }
                                functionDepth--;
                                if (functionDepth < 0) {
                                    functionDepth = 0;
                                }
                                break;

                            case '@{':
                            case '#{':
                                // Expression with LESS/SASS syntax enabled
                                if (_this2.splitRules) {
                                    var _row = {
                                        type: 'text',
                                        text: _this2._css.slice(start, token.index + 2),
                                        index: start
                                    };
                                    if (!expressionDepth) {
                                        _row.beforeExpression = true;
                                    }
                                    words.push(_row);
                                    start = token.index + 2;
                                }
                                expressionDepth++;
                                break;
                        }
                    });

                    if (depth > 0 && !this.ignoreErrors) {
                        this.errors.push(new ParseError('Missing }', this._css, cssLength));
                    }

                    // Add remaining code
                    if (this.splitRules) {
                        words.push({
                            type: 'text',
                            text: this._css.slice(start),
                            index: start
                        });
                        items.push(this._checkRule(words, '', error));
                        if (error) {
                            items[items.length - 1].error = true;
                        }
                    } else {
                        var code = this._css.slice(blockStart).trim();
                        if (code.length) {
                            items.push({
                                token: 'code',
                                code: code,
                                index: blockStart
                            });
                            if (error) {
                                items[items.length - 1].error = true;
                            }
                        }
                    }
                    return items.filter(function (row) {
                        return row !== false;
                    });
                }

                /**
                 * Find tokens in code
                 *
                 * @param {Array} tokens Array of tokens
                 * @returns {Array}
                 */

            }, {
                key: '_findTokens',
                value: function _findTokens(tokens) {
                    var _this3 = this;

                    var list = [];

                    tokens.forEach(function (token) {
                        var index = 0;
                        while (true) {
                            index = _this3._cssLC.indexOf(token, index);
                            if (index === -1) {
                                return;
                            }
                            list.push({
                                token: token,
                                index: index
                            });
                            index++;
                        }
                    });

                    list.sort(function (a, b) {
                        return a.index - b.index;
                    });
                    return list;
                }

                /**
                 * Find end of quoted string
                 *
                 * @param {string} quote Quote character
                 * @param {number} start Position of first quote
                 * @returns {number|boolean} Position of character after end of string, false if string is broken
                 */

            }, {
                key: '_findEndOfQuotedString',
                value: function _findEndOfQuotedString(quote, start) {
                    var nextEscape = this._css.indexOf('\\', start + 1),
                        end = this._css.indexOf(quote, start + 1);

                    if (end === -1) {
                        // Invalid string
                        return false;
                    }

                    while (nextEscape !== -1 && nextEscape < end) {
                        if (end === nextEscape + 1) {
                            end = this._css.indexOf(quote, end + 1);
                            if (end === -1) {
                                // Invalid string
                                return false;
                            }
                        }
                        nextEscape = this._css.indexOf('\\', nextEscape + 2);
                    }

                    return end + 1;
                }

                /**
                 * Find end of url
                 *
                 * @param {number} start
                 * @returns {number|ParseError} Position of character after end of url() or error message
                 */

            }, {
                key: '_findEndOfURL',
                value: function _findEndOfURL(start) {
                    var index = (start || 0) + 4,
                        length = this._css.length,
                        next = void 0,
                        end = void 0;

                    while (index < length) {
                        next = this._css.charAt(index);
                        switch (next) {
                            case '"':
                            case "'":
                                // quoted url
                                end = this._findEndOfQuotedString(next, index);
                                if (end === false) {
                                    return new ParseError('Incomplete string', this._css, index);
                                }
                                end = this._css.indexOf(')', end);
                                return end === -1 ? new ParseError('Cannot find end of URL', this._css, start) : end + 1;

                            case ' ':
                            case '\t':
                            case '\r':
                            case '\n':
                                // skip whitespace
                                index++;
                                break;

                            default:
                                // unquoted url
                                while (true) {
                                    switch (next) {
                                        case ')':
                                            return index + 1;

                                        case '"':
                                        case "'":
                                        case '(':
                                        case ' ':
                                        case '\t':
                                        case '\r':
                                        case '\n':
                                            return new ParseError('Invalid URL', this._css, start);

                                        default:
                                            if (this._css.charCodeAt(index) < 32) {
                                                return new ParseError('Invalid URL', this._css, start);
                                            }
                                    }
                                    index++;
                                    if (index >= length) {
                                        return new ParseError('Cannot find end of URL', this._css, start);
                                    }
                                    next = this._css.charAt(index);
                                }
                        }
                    }
                    return new ParseError('Cannot find end of URL', this._css, start);
                }

                /**
                 * Check for valid css rule, return either code or rule token
                 *
                 * @param {Array} words Array of words
                 * @param {string} extra Additional text to add if returning code
                 * @param {boolean} ignoreErrors True if errors should be ignored
                 * @returns {Object|boolean}
                 * @private
                 */

            }, {
                key: '_checkRule',
                value: function _checkRule(words, extra, ignoreErrors) {
                    var pairs = this._findRulePairs(words),
                        value = void 0,
                        index = void 0;

                    if (typeof pairs === 'boolean') {
                        value = this._mergeWords(words) + extra;
                        if (!value.length) {
                            return false;
                        }

                        index = words[0].index;
                        if (pairs === false && !this.ignoreErrors && !ignoreErrors) {
                            this.errors.push(new ParseError('Invalid css rule', this._css, index));
                        }
                        return {
                            token: 'code',
                            code: value,
                            index: index
                        };
                    }
                    return pairs;
                }

                /**
                 * Merge words list to string
                 *
                 * @param {Array} words
                 * @returns {string}
                 * @private
                 */

            }, {
                key: '_mergeWords',
                value: function _mergeWords(words) {
                    return words.map(function (word) {
                        return word.text;
                    }).join('').trim();
                }

                /**
                 * Get token with selectors list
                 *
                 * @param {Array} words
                 * @returns {Object}
                 * @private
                 */

            }, {
                key: '_checkSelectors',
                value: function _checkSelectors(words) {
                    var selectors = this._getSelectors(words),
                        result = {
                        token: '{',
                        code: this._mergeWords(words),
                        index: words[0].index
                    };

                    if (!selectors.length) {
                        return result;
                    }

                    if (selectors[0].charAt(0) === '@') {
                        result.atRule = selectors[0].split(/\s+/, 1)[0].slice(1);
                        selectors[0] = selectors[0].slice(1 + result.atRule.length).trim();
                        result.atValues = selectors;
                    } else {
                        result.selectors = selectors;
                    }

                    return result;
                }

                /**
                 * Get list of selectors from list of words
                 *
                 * @param {Array} words
                 * @returns {Array}
                 * @private
                 */

            }, {
                key: '_getSelectors',
                value: function _getSelectors(words) {
                    var selectors = [],
                        selector = '';

                    words.forEach(function (word) {
                        if (word.type !== 'text') {
                            selector += word.text;
                            return;
                        }

                        var list = word.text.split(',');
                        selector += list.shift();
                        while (list.length > 0) {
                            selectors.push(selector.trim());
                            selector = list.shift();
                        }
                    });

                    selectors.push(selector.trim());

                    return selectors.filter(function (item) {
                        return item.length > 0;
                    });
                }

                /**
                 * Get key/value pairs from list of words
                 *
                 * @param {Array} words
                 * @returns {Object|boolean}
                 * @private
                 */

            }, {
                key: '_findRulePairs',
                value: function _findRulePairs(words) {
                    var _this4 = this;

                    var key = '',
                        value = '',
                        isKey = true,
                        error = false,
                        hasFunction = false,
                        result = void 0;

                    words.forEach(function (word) {
                        if (error) {
                            return;
                        }

                        if (word.type !== 'text') {
                            if (isKey) {
                                if (!_this4.lessSyntax) {
                                    // Cannot have URL or quoted string in key
                                    error = true;
                                    return;
                                }

                                // Check for function
                                if (word.type === 'function') {
                                    hasFunction = true;
                                }
                                key += word.text;
                                return;
                            }
                            value += word.text;
                            return;
                        }

                        var pairs = word.text.split(':');
                        if (_this4.lessSyntax && pairs.length > 1) {
                            // Check for "&:extend" LESS syntax
                            pairs.forEach(function (item, index) {
                                if (index > 0 && (item === 'extend' || item.slice(0, 7) === 'extend(')) {
                                    pairs[index - 1] += ':' + pairs[index];
                                    pairs[index] = null;
                                }
                            });
                            pairs = pairs.filter(function (item) {
                                return item !== null;
                            });
                        }

                        if (pairs.length > 2) {
                            error = true;
                            return;
                        }
                        if (pairs.length === 2) {
                            if (!isKey) {
                                error = true;
                                return;
                            }
                            key += pairs[0];
                            value = pairs[1];
                            isKey = false;
                            return;
                        }
                        if (isKey) {
                            key += word.text;
                        } else {
                            value += word.text;
                        }
                    });

                    if (error) {
                        return false;
                    }
                    if (isKey) {
                        // True if token should be treated as code
                        return this.lessSyntax ? hasFunction || key.trim().slice(0, 1) === '@' : false;
                    }

                    key = key.trim();
                    value = value.trim();
                    if (!key.length || !value.length) {
                        return false;
                    }

                    result = {
                        token: 'rule',
                        key: key,
                        value: value,
                        index: words[0].index
                    };

                    this.ruleModifiers.forEach(function (word) {
                        if (result.value.slice(0 - word.length - 1).toLowerCase() === '!' + word) {
                            result[word] = true;
                            result.value = result.value.slice(0, result.value.length - word.length - 1).trim();
                        }
                    });
                    if (!result.value.length) {
                        return false;
                    }

                    return result;
                }

                /**
                 * Convert to tree
                 *
                 * @param item
                 * @returns {Array}
                 * @private
                 */

            }, {
                key: '_parseTokens',
                value: function _parseTokens(item) {
                    var results = [];

                    while (item !== void 0) {
                        switch (item.token) {
                            case '}':
                                return results;

                            case '{':
                                item.children = this._parseTokens(this._tokens.shift());
                                results.push(item);
                                break;

                            default:
                                results.push(item);
                        }

                        item = this._tokens.shift();
                    }
                    return results;
                }
            }]);

            return Tokenizer;
        }();

        modules['Tokenizer'] = Tokenizer;
    })();

    // Export to global namespace
    _global.CATokenizer = modules.Tokenizer;
})(typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" ? self : typeof global !== "undefined" ? global : Function("return this;")());
